// Generated by CoffeeScript 1.7.1
(function() {
  var CodeParser;

  CodeParser = (function() {
    function CodeParser() {}

    CodeParser.buildAst = function(source) {
      var i, indent, indentStart, line, lines, output, subexp, words, _i, _len;
      lines = source.split('\n').filter(function(line) {
        return line.replace(/\s/, '') !== '';
      });
      output = [];
      indent = false;
      indentStart = 0;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        if (line.substr(0, 4) === '    ') {
          if (!indent) {
            indent = true;
            indentStart = i;
          }
          lines[i] = line.substr(4);
        } else if (indent === true) {
          indent = false;
          subexp = lines.slice(indentStart, i).join('\n');
          output[output.length - 1].instructions = CodeParser.buildAst(subexp);
        }
        if (!indent) {
          words = line.split(' ');
          if (words[0] === 'if') {
            output.push({
              type: 'conditional',
              cond: words.slice(1).join(' '),
              code: line
            });
          } else if (words[0] === 'module') {
            output.push({
              type: 'module declaration',
              name: words[1],
              code: line
            });
          } else {
            output.push({
              type: 'command',
              action: line,
              code: line
            });
          }
        }
      }
      if (indent) {
        subexp = lines.slice(indentStart, i).join('\n');
        output[output.length - 1].instructions = CodeParser.buildAst(subexp);
      }
      return output;
    };

    CodeParser.reconstructCode = function(ast, tabs) {
      var code, node, _i, _len, _ref, _results;
      code = '';
      tabs = tabs || '';
      _results = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        code += tabs + node.code + '\n';
        if ((_ref = node.type) === 'conditional' || _ref === 'module declaration') {
          _results.push(code += CodeParser.reconstructCode(node.instructions, tabs + '    '));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CodeParser.makeInstructions = function(ast) {
      var action, cond, direction, inst, instructions, js, module, name, node, operator, processed, value, _i, _len, _ref;
      processed = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        inst = {};
        if (node.type === 'conditional') {
          instructions = CodeParser.makeInstructions(node.instructions);
          cond = node.cond.split(' ');
          (function(instructions, cond) {
            var conditionFn, key, name, operator, value;
            conditionFn = null;
            switch (cond[0]) {
              case 'see':
                conditionFn = function(action, drone, map) {
                  var seenTile;
                  seenTile = map.getTile(drone.x + drone.direction.x, drone.y + drone.direction.y);
                  return seenTile.tileContentName === cond[1];
                };
                break;
              case 'memory':
                name = cond[1];
                operator = cond[2];
                value = cond[3];
                (function(value) {
                  var getValue;
                  getValue = null;
                  if (!isNaN(value)) {
                    value = +value;
                    getValue = function() {
                      return value;
                    };
                  } else {
                    getValue = function(memory) {
                      return memory[value] || 0;
                    };
                  }
                  return (function(name, operator, getValue) {
                    return conditionFn = function(action, drone, map) {
                      var val;
                      val = getValue(drone.memory);
                      return (operator === 'not' && drone.memory[name] !== val) || (operator === 'is' && drone.memory[name] === val);
                    };
                  })(name, operator, getValue);
                })(value);
                break;
              case 'input':
                key = cond[1];
                (function(key) {
                  return conditionFn = function(action, drone, map, inputs) {
                    return inputs.some(function(inp) {
                      return inp === Phaser.Keyboard[key];
                    });
                  };
                })(key);
                break;
              default:
                throw "Unsupported condition " + cond[0];
            }
            return (function(conditionFn) {
              return inst.execute = function(action, drone, map, inputs) {
                var subInstruction, _j, _len1, _results;
                if (conditionFn(action, drone, map, inputs)) {
                  _results = [];
                  for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                    subInstruction = instructions[_j];
                    _results.push(subInstruction.execute(action, drone, map));
                  }
                  return _results;
                }
              };
            })(conditionFn);
          })(instructions, cond);
        } else if (node.type === 'module declaration') {
          instructions = CodeParser.makeInstructions(node.instructions);
          module = {
            name: node.name,
            code: CodeParser.reconstructCode(node.instructions),
            instructions: instructions
          };
          (function(module) {
            return inst.execute = function(action, drone, map) {
              return drone.loadModule(module);
            };
          })(module);
        } else if (node.type === 'command') {
          action = node.action.split(' ');
          switch (action[0]) {
            case 'dig':
              direction = action[1];
              (function(direction) {
                return inst.execute = function(action, drone, map) {
                  var targetCoords;
                  targetCoords = {
                    x: 0,
                    y: 0
                  };
                  if (direction === 'forward') {
                    targetCoords = {
                      x: drone.x + drone.direction.x,
                      y: drone.y + drone.direction.y
                    };
                  }
                  action.digTile = targetCoords;
                  return action.move = targetCoords;
                };
              })(direction);
              break;
            case 'rotate':
              direction = action[1];
              (function(direction) {
                return inst.execute = function(action, drone, map) {
                  return action.rotate = {
                    direction: direction
                  };
                };
              })(direction);
              break;
            case 'increment':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  if (drone.memory[name] == null) {
                    drone.memory[name] = 0;
                  }
                  return drone.memory[name]++;
                };
              })(name);
              break;
            case 'decrement':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  if (drone.memory[name] == null) {
                    drone.memory[name] = 0;
                  }
                  return drone.memory[name]--;
                };
              })(name);
              break;
            case 'set_module':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  return drone.activeModule = name;
                };
              })(name);
              break;
            case 'send_module':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  return action.sendModule = name;
                };
              })(name);
              break;
            case 'debug':
              js = action.slice(1).join(' ');
              (function(js) {
                return inst.execute = function(action, drone, map) {
                  var fn, prop, value, _ref;
                  _ref = drone.memory;
                  for (prop in _ref) {
                    value = _ref[prop];
                    js = ("var " + prop + " = " + value + ";") + js;
                  }
                  fn = Function(js);
                  return fn();
                };
              })(js);
              break;
            default:
              if ((_ref = action[0]) === 'set' || _ref === 'add' || _ref === 'mult' || _ref === 'sub' || _ref === 'div') {
                name = action[1];
                value = action[2];
                operator = {
                  set: '',
                  add: '+',
                  mult: '*',
                  sub: '-',
                  div: '/'
                }[action[0]];
                (function(value, operator) {
                  var getValue;
                  getValue = null;
                  if (!isNaN(value)) {
                    value = +value;
                    getValue = function() {
                      return value;
                    };
                  } else {
                    getValue = function(memory) {
                      return memory[value] || 0;
                    };
                  }
                  return (function(name, getValue) {
                    return eval("inst.execute = function (action, drone, map) {\n    drone.memory[name] " + operator + "= getValue(drone.memory);\n}");
                  })(name, getValue);
                })(value, operator);
              } else {
                throw "Unsuported command " + action[0];
              }
          }
        }
        processed.push(inst);
      }
      return processed;
    };

    CodeParser.compileCode = CodeParser.makeInstructions.compose(CodeParser.buildAst);

    return CodeParser;

  })();

  window.CodeParser = CodeParser;

  CodeParser.testCode = 'if input A\n    rotate ccw\nif input D\n    rotate cw\nif input W\n    dig forward';


  /*
  Language docs
  instruction ::= 'if' cond | action
  value       ::= identifier | number
  cond        ::= 'see' tile |
                  'memory' identifier compare value
  tile        ::= 'dirt' | 'stone' | ...
  identifier  ::= string
  compare     ::= 'is' | 'not'
  action      ::= 'set' identifier value |
                  'dig forward' |
                  'rotate' rot_dir |
                  'increment' identifier |
                  'decrement' identifier |
                  'add' identifier value |
                  'sub' identifier value |
                  'mult' identifier value |
                  'div' identifier value
  rot_dir     ::= 'cw' | 'ccw'
   */

}).call(this);

//# sourceMappingURL=CodeParser.map
