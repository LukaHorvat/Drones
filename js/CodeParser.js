// Generated by CoffeeScript 1.7.1
(function() {
  var CodeParser, testAst, testCode;

  CodeParser = (function() {
    function CodeParser() {}

    CodeParser.buildAst = function(source) {
      var i, indent, indentStart, line, lines, output, subexp, words, _i, _len;
      lines = source.split('\n').filter(function(line) {
        return line.replace(/\s/, '') !== '';
      });
      output = [];
      indent = false;
      indentStart = 0;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        if (line.substr(0, 4) === '    ') {
          if (!indent) {
            indent = true;
            indentStart = i;
          }
          lines[i] = line.substr(4);
        } else if (indent === true) {
          indent = false;
          subexp = lines.slice(indentStart, i).join('\n');
          output[output.length - 1].instructions = CodeParser.buildAst(subexp);
        }
        if (!indent) {
          words = line.split(' ');
          if (words[0] === 'if') {
            output.push({
              cond: words.slice(1).join(' ')
            });
          } else {
            output.push({
              action: line
            });
          }
        }
      }
      if (indent) {
        subexp = lines.slice(indentStart, i).join('\n');
        output[output.length - 1].instructions = CodeParser.buildAst(subexp);
      }
      return output;
    };

    CodeParser.makeInstructions = function(ast) {
      var action, cond, direction, inst, instructions, js, name, node, processed, value, _i, _len, _ref;
      processed = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        inst = {};
        if (node.cond) {
          instructions = CodeParser.makeInstructions(node.instructions);
          cond = node.cond.split(' ');
          (function(instructions, cond) {
            var name, operator, value;
            if (cond[0] === 'see') {
              return inst.execute = function(action, drone, map) {
                var seenTile, subInstruction, _j, _len1, _results;
                seenTile = map.getTile(drone.x + drone.direction.x, drone.y + drone.direction.y);
                if (seenTile.tileContentName === cond[1]) {
                  _results = [];
                  for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                    subInstruction = instructions[_j];
                    _results.push(subInstruction.execute(action, drone, map));
                  }
                  return _results;
                }
              };
            } else if (cond[0] === 'memory') {
              name = cond[1];
              operator = cond[2];
              value = cond[3];
              return (function(value) {
                var getValue;
                getValue = null;
                if (!isNaN(value)) {
                  value = +value;
                  getValue = function() {
                    return value;
                  };
                } else {
                  getValue = function(memory) {
                    return memory[value] || 0;
                  };
                }
                return (function(name, operator, getValue) {
                  return inst.execute = function(action, drone, map) {
                    var subInstruction, val, _j, _k, _len1, _len2, _results;
                    val = getValue(drone.memory);
                    if (operator === 'not' && drone.memory[name] !== val) {
                      for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                        subInstruction = instructions[_j];
                        subInstruction.execute(action, drone, map);
                      }
                    }
                    if (operator === 'is' && drone.memory[name] === val) {
                      _results = [];
                      for (_k = 0, _len2 = instructions.length; _k < _len2; _k++) {
                        subInstruction = instructions[_k];
                        _results.push(subInstruction.execute(action, drone, map));
                      }
                      return _results;
                    }
                  };
                })(name, operator, getValue);
              })(value);
            } else {
              throw "Unsupported condition " + cond[0];
            }
          })(instructions, cond);
        } else {
          action = node.action.split(' ');
          if (action[0] === 'dig') {
            direction = action[1];
            (function(direction) {
              return inst.execute = function(action, drone, map) {
                var targetCoords;
                targetCoords = {
                  x: 0,
                  y: 0
                };
                if (direction === 'forward') {
                  targetCoords = {
                    x: drone.x + drone.direction.x,
                    y: drone.y + drone.direction.y
                  };
                }
                action.digTile = targetCoords;
                return action.move = targetCoords;
              };
            })(direction);
          } else if (action[0] === 'rotate') {
            direction = action[1];
            (function(direction) {
              return inst.execute = function(action, drone, map) {
                return action.rotate = {
                  direction: direction
                };
              };
            })(direction);
          } else if (action[0] === 'increment') {
            name = action[1];
            (function(name) {
              return inst.execute = function(action, drone, map) {
                if (drone.memory[name] == null) {
                  drone.memory[name] = 0;
                }
                return drone.memory[name]++;
              };
            })(name);
          } else if (action[0] === 'decrement') {
            name = action[1];
            (function(name) {
              return inst.execute = function(action, drone, map) {
                if (drone.memory[name] == null) {
                  drone.memory[name] = 0;
                }
                return drone.memory[name]--;
              };
            })(name);
          } else if ((_ref = action[0]) === 'set' || _ref === 'add' || _ref === 'mult' || _ref === 'sub' || _ref === 'div') {
            name = action[1];
            value = action[2];
            (function(value) {
              var getValue;
              getValue = null;
              if (!isNaN(value)) {
                value = +value;
                getValue = function() {
                  return value;
                };
              } else {
                getValue = function(memory) {
                  return memory[value] || 0;
                };
              }
              return (function(name, getValue) {
                switch (action[0]) {
                  case 'set':
                    return inst.execute = function(action, drone, map) {
                      return drone.memory[name] = getValue(drone.memory);
                    };
                  case 'add':
                    return inst.execute = function(action, drone, map) {
                      return drone.memory[name] += getValue(drone.memory);
                    };
                  case 'mult':
                    return inst.execute = function(action, drone, map) {
                      return drone.memory[name] *= getValue(drone.memory);
                    };
                  case 'sub':
                    return inst.execute = function(action, drone, map) {
                      return drone.memory[name] -= getValue(drone.memory);
                    };
                  case 'div':
                    return inst.execute = function(action, drone, map) {
                      return drone.memory[name] /= getValue(drone.memory);
                    };
                }
              })(name, getValue);
            })(value);
          } else if (action[0] === 'debug') {
            js = action.slice(1).join(' ');
            (function(js) {
              return inst.execute = function(action, drone, map) {
                var fn, prop, _ref1;
                _ref1 = drone.memory;
                for (prop in _ref1) {
                  value = _ref1[prop];
                  js = ("var " + prop + " = " + value + ";") + js;
                }
                fn = Function(js);
                return fn();
              };
            })(js);
          } else {
            throw "Unsuported command " + action[0];
          }
        }
        processed.push(inst);
      }
      return processed;
    };

    CodeParser.compileCode = CodeParser.makeInstructions.compose(CodeParser.buildAst);

    return CodeParser;

  })();

  window.CodeParser = CodeParser;

  testCode = 'set sawDirt 0\nif see dirt\n    dig forward\n    set sawDirt 1\n    set count 0\nif memory sawDirt not 1\n    increment count\n    rotate cw\n    if memory count is 4\n        dig forward\n        set count 0';

  testAst = CodeParser.buildAst(testCode);

  CodeParser.testInstructions = CodeParser.makeInstructions(testAst);


  /*
  Language docs
  instruction ::= 'if' cond | action
  value       ::= identifier | number
  cond        ::= 'see' tile |
                  'memory' identifier compare value
  tile        ::= 'dirt' | 'stone' | ...
  identifier  ::= string
  compare     ::= 'is' | 'not'
  action      ::= 'set' identifier value |
                  'dig forward' |
                  'rotate' rot_dir |
                  'increment' identifier |
                  'decrement' identifier |
                  'add' identifier value |
                  'sub' identifier value |
                  'mult' identifier value |
                  'div' identifier value
  rot_dir     ::= 'cw' | 'ccw'
   */

}).call(this);
