// Generated by CoffeeScript 1.7.1
(function() {
  var CodeParser;

  CodeParser = (function() {
    function CodeParser() {}

    CodeParser.buildAst = function(source) {
      var i, indent, indentStart, line, lines, output, subexp, words, _i, _len;
      lines = source.split('\n').filter(function(line) {
        return line.replace(/\s/, '') !== '';
      });
      output = [];
      indent = false;
      indentStart = 0;
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        if (line.substr(0, 4) === '    ') {
          if (!indent) {
            indent = true;
            indentStart = i;
          }
          lines[i] = line.substr(4);
        } else if (indent === true) {
          indent = false;
          subexp = lines.slice(indentStart, i).join('\n');
          output[output.length - 1].instructions = CodeParser.buildAst(subexp);
        }
        if (!indent) {
          words = line.split(' ');
          if (words[0] === 'if') {
            output.push({
              type: 'conditional',
              cond: words.slice(1).join(' '),
              code: line
            });
          } else if (words[0] === 'module') {
            output.push({
              type: 'module declaration',
              name: words[1],
              code: line
            });
          } else {
            output.push({
              type: 'command',
              action: line,
              code: line
            });
          }
        }
      }
      if (indent) {
        subexp = lines.slice(indentStart, i).join('\n');
        output[output.length - 1].instructions = CodeParser.buildAst(subexp);
      }
      return output;
    };

    CodeParser.reconstructCode = function(ast, tabs) {
      var code, node, _i, _len, _ref, _results;
      code = '';
      tabs = tabs || '';
      _results = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        code += tabs + node.code + '\n';
        if ((_ref = node.type) === 'conditional' || _ref === 'module declaration') {
          _results.push(code += CodeParser.reconstructCode(node.instructions, tabs + '\t'));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    CodeParser.makeInstructions = function(ast) {
      var action, cond, direction, inst, instructions, js, module, name, node, operator, processed, value, _i, _len, _ref;
      processed = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        inst = {};
        if (node.type === 'conditional') {
          instructions = CodeParser.makeInstructions(node.instructions);
          cond = node.cond.split(' ');
          (function(instructions, cond) {
            var name, operator, value;
            if (cond[0] === 'see') {
              return inst.execute = function(action, drone, map) {
                var seenTile, subInstruction, _j, _len1, _results;
                seenTile = map.getTile(drone.x + drone.direction.x, drone.y + drone.direction.y);
                if (seenTile.tileContentName === cond[1]) {
                  _results = [];
                  for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                    subInstruction = instructions[_j];
                    _results.push(subInstruction.execute(action, drone, map));
                  }
                  return _results;
                }
              };
            } else if (cond[0] === 'memory') {
              name = cond[1];
              operator = cond[2];
              value = cond[3];
              return (function(value) {
                var getValue;
                getValue = null;
                if (!isNaN(value)) {
                  value = +value;
                  getValue = function() {
                    return value;
                  };
                } else {
                  getValue = function(memory) {
                    return memory[value] || 0;
                  };
                }
                return (function(name, operator, getValue) {
                  return inst.execute = function(action, drone, map) {
                    var subInstruction, val, _j, _k, _len1, _len2, _results;
                    val = getValue(drone.memory);
                    if (operator === 'not' && drone.memory[name] !== val) {
                      for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                        subInstruction = instructions[_j];
                        subInstruction.execute(action, drone, map);
                      }
                    }
                    if (operator === 'is' && drone.memory[name] === val) {
                      _results = [];
                      for (_k = 0, _len2 = instructions.length; _k < _len2; _k++) {
                        subInstruction = instructions[_k];
                        _results.push(subInstruction.execute(action, drone, map));
                      }
                      return _results;
                    }
                  };
                })(name, operator, getValue);
              })(value);
            } else {
              throw "Unsupported condition " + cond[0];
            }
          })(instructions, cond);
        } else if (node.type === 'module declaration') {
          instructions = CodeParser.makeInstructions(node.instructions);
          module = {
            name: node.name,
            code: CodeParser.reconstructCode(node.instructions),
            instructions: instructions
          };
          (function(module) {
            return inst.execute = function(action, drone, map) {
              return drone.loadModule(module);
            };
          })(module);
        } else if (node.type === 'command') {
          action = node.action.split(' ');
          switch (action[0]) {
            case 'dig':
              direction = action[1];
              (function(direction) {
                return inst.execute = function(action, drone, map) {
                  var targetCoords;
                  targetCoords = {
                    x: 0,
                    y: 0
                  };
                  if (direction === 'forward') {
                    targetCoords = {
                      x: drone.x + drone.direction.x,
                      y: drone.y + drone.direction.y
                    };
                  }
                  action.digTile = targetCoords;
                  return action.move = targetCoords;
                };
              })(direction);
              break;
            case 'rotate':
              direction = action[1];
              (function(direction) {
                return inst.execute = function(action, drone, map) {
                  return action.rotate = {
                    direction: direction
                  };
                };
              })(direction);
              break;
            case 'increment':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  if (drone.memory[name] == null) {
                    drone.memory[name] = 0;
                  }
                  return drone.memory[name]++;
                };
              })(name);
              break;
            case 'decrement':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  if (drone.memory[name] == null) {
                    drone.memory[name] = 0;
                  }
                  return drone.memory[name]--;
                };
              })(name);
              break;
            case 'set_module':
              name = action[1];
              (function(name) {
                return inst.execute = function(action, drone, map) {
                  return drone.setModule = name;
                };
              })(name);
              break;
            case 'debug':
              js = action.slice(1).join(' ');
              (function(js) {
                return inst.execute = function(action, drone, map) {
                  var fn, prop, value, _ref;
                  _ref = drone.memory;
                  for (prop in _ref) {
                    value = _ref[prop];
                    js = ("var " + prop + " = " + value + ";") + js;
                  }
                  fn = Function(js);
                  return fn();
                };
              })(js);
              break;
            default:
              if ((_ref = action[0]) === 'set' || _ref === 'add' || _ref === 'mult' || _ref === 'sub' || _ref === 'div') {
                name = action[1];
                value = action[2];
                operator = {
                  set: '',
                  add: '+',
                  mult: '*',
                  sub: '-',
                  div: '/'
                }[action[0]];
                (function(value, operator) {
                  var getValue;
                  getValue = null;
                  if (!isNaN(value)) {
                    value = +value;
                    getValue = function() {
                      return value;
                    };
                  } else {
                    getValue = function(memory) {
                      return memory[value] || 0;
                    };
                  }
                  return (function(name, getValue) {
                    return eval("inst.execute = function (action, drone, map) {\n    drone.memory[name] " + operator + "= getValue(drone.memory);\n}");
                  })(name, getValue);
                })(value, operator);
              } else {
                throw "Unsuported command " + action[0];
              }
          }
        }
        processed.push(inst);
      }
      return processed;
    };

    CodeParser.compileCode = CodeParser.makeInstructions.compose(CodeParser.buildAst);

    return CodeParser;

  })();

  window.CodeParser = CodeParser;

  CodeParser.testCode = 'set sawDirt 0\nif see dirt\n    dig forward\n    set sawDirt 1\n    set count 0\nif memory sawDirt not 1\n    increment count\n    rotate cw\n    if memory count is 4\n        dig forward\n        set count 0';


  /*
  Language docs
  instruction ::= 'if' cond | action
  value       ::= identifier | number
  cond        ::= 'see' tile |
                  'memory' identifier compare value
  tile        ::= 'dirt' | 'stone' | ...
  identifier  ::= string
  compare     ::= 'is' | 'not'
  action      ::= 'set' identifier value |
                  'dig forward' |
                  'rotate' rot_dir |
                  'increment' identifier |
                  'decrement' identifier |
                  'add' identifier value |
                  'sub' identifier value |
                  'mult' identifier value |
                  'div' identifier value
  rot_dir     ::= 'cw' | 'ccw'
   */

}).call(this);
