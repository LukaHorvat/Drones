// Generated by CoffeeScript 1.7.1
(function() {
  var CodeParser, testCode;

  CodeParser = (function() {
    function CodeParser() {}

    CodeParser.makeInstructions = function(ast) {
      var action, cond, direction, inst, instructions, name, node, processed, value, _i, _len;
      processed = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        node = ast[_i];
        inst = {};
        if (node.cond) {
          instructions = this.makeInstructions(node.instructions);
          cond = node.cond.split(' ');
          (function(instructions, cond) {
            var name, operator, value;
            if (cond[0] === 'see') {
              inst.execute = function(action, drone, map) {
                var seenTile, subInstruction, _j, _len1, _results;
                seenTile = map[drone.x + drone.direction.x][drone.y + drone.direction.y];
                if (seenTile.tileContent === game.tileIndexByName[cond[1]]) {
                  _results = [];
                  for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                    subInstruction = instructions[_j];
                    _results.push(subInstruction.execute(action, drone, map));
                  }
                  return _results;
                }
              };
            }
            if (cond[0] === 'memory') {
              name = cond[1];
              operator = cond[2];
              value = cond[3];
              return (function(name, operator, value) {
                return inst.execute = function(action, drone, map) {
                  var subInstruction, _j, _len1, _results;
                  if (operator === 'not' && drone.memory[name] !== value) {
                    _results = [];
                    for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
                      subInstruction = instructions[_j];
                      _results.push(subInstruction.execute(action, drone, map));
                    }
                    return _results;
                  }
                };
              })(name, operator, value);
            }
          })(instructions, cond);
        } else {
          action = node.action.split(' ');
          if (action[0] === 'dig') {
            direction = action[1];
            (function(direction) {
              return inst.execute = function(action, drone, map) {
                var targetCoords;
                targetCoords = {
                  x: 0,
                  y: 0
                };
                if (direction === 'forward') {
                  targetCoords = {
                    x: drone.x + drone.direction.x,
                    y: drone.y + drone.direction.y
                  };
                }
                action.digTile = targetCoords;
                return action.move = targetCoords;
              };
            })(direction);
          }
          if (action[0] === 'set') {
            name = action[1];
            value = action[2];
            (function(name, value) {
              return inst.execute = function(action, drone, map) {
                return drone.memory[name] = value;
              };
            })(name, value);
          }
          if (action[0] === 'rotate') {
            direction = action[1];
            (function(direction) {
              return inst.execute = function(action, drone, map) {
                return action.rotate = {
                  direction: direction
                };
              };
            })(direction);
          }
        }
        processed.push(inst);
      }
      return processed;
    };

    return CodeParser;

  })();

  window.CodeParser = CodeParser;

  testCode = [
    {
      action: 'set dirt 0'
    }, {
      cond: 'see dirt',
      instructions: [
        {
          action: 'dig forward'
        }, {
          action: 'set dirt 1'
        }
      ]
    }, {
      cond: 'memory dirt not 1',
      instructions: [
        {
          action: 'rotate cw'
        }
      ]
    }
  ];

  CodeParser.testInstructions = CodeParser.makeInstructions(testCode);

}).call(this);
